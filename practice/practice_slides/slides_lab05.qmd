---
title: "Lab 5: Intro to Machine Learning"
subtitle: "<span style='font-size:2em;'> Practice session</span>"
#author: "Luisa M. Mimmi | [https://luisamimmi.org/](https://luisamimmi.org/)"
author: "<span style='font-size:1.3em; font-weight: bold; color:#77501a'> Luisa M. Mimmi — &ensp;</span>  <a href='https://luisamimmi.org/' style='color:#72aed8; font-weight:600; font-size:1.3em;'>https://luisamimmi.org/</a>"
date: today
date-format: long
code-link: true
format:
  revealjs:
    math: mathjax
    smaller: true
    scrollable: true
    theme: ../../theme/slidesMine.scss # QUARTO LOOKS IN SAME FOLDER 
#    logo: imgs_slides/mitgest_logo.png
    footer: '[R 4 Statistics]({{< var websites.live_site >}}) | 2024'
#    footer: <https://lulliter.github.io/R4biostats/lectures.html>
## ------------- x salvare come PDF 
    standalone: false
    ## -------Produce a standalone HTML file with no external dependencies,
    embed-resources: true
    transition: fade
    background-transition: fade
    highlight-style: ayu-mirage
    slide-number: true
    fig-cap-location: top
    # fig-format: svg
    pdf-separate-fragments: false
    # fig-align: center
execute:
  # Quarto pre code blocks do not echo their source code by default
  echo: true
  include: true
  freeze: auto
bibliography: ../../bib/R4biostats.bib
csl: ../../bib/apa-6th-edition.csl 
suppress-bibliography: true
---


# [GOAL OF TODAY'S PRACTICE SESSION]{.fit-title}

::: {style="font-size: 100%;"}
::: {style="color:#77501a"}

+ In this Lab session, we will focus on **Machine Learning** (ML), as introduced in Lecture 5
+ We will review examples of both **supervised** and **unsupervised** ML algorithms
  +  **Supervised ML algorithms** examples
    + Logistic regression
    + 🌳 Random Forest / decision trees 🌲
  + **Unsupervised ML algorithms** examples
    + K-means Clustering
    + PCA for dimension reduction
  + (optional) PLS-DA for classification, a supervised ML alternative to PCA
    
:::
:::

 



## 🟠 ACKNOWLEDGEMENTS

 
The examples and datasets in this Lab session follow very closely two sources:

1. The tutorial on "Principal Component Analysis (PCA) in R" by: [Statistics Globe](https://statisticsglobe.com/principal-component-analysis-r)
2. 

<!-- The materials in support of the "Core Statistics using R" course by: [Martin van Rongen](https://github.com/mvanrongen/corestats-in-r_tidyverse) -->
<!-- POWER ANALYSIS https://mvanrongen.github.io/corestats-in-r_tidyverse/power-analysis.html -->
 

# R ENVIRONMENT SET UP & DATA

## Needed R Packages
::: {style="font-size: 85%;"}

+ We will use functions from packages `base`, `utils`, and `stats` (pre-installed and pre-loaded) 
+ We may also use the packages below (specifying `package::function` for clarity).


```{r}
# Load pckgs for this R session

# --- General 
library(here)     # tools find your project's files, based on working directory
library(dplyr)    # A Grammar of Data Manipulation
library(skimr)    # Compact and Flexible Summaries of Data
library(magrittr) # A Forward-Pipe Operator for R 
library(readr)    # A Forward-Pipe Operator for R 
library(tidyr)    # Tidy Messy Data
library(kableExtra) # Construct Complex Table with 'kable' and Pipe Syntax

# ---Plotting & data visualization
library(ggplot2)      # Create Elegant Data Visualisations Using the Grammar of Graphics
library(ggfortify)     # Data Visualization Tools for Statistical Analysis Results
library(scatterplot3d) # 3D Scatter Plot

# --- Statistics
library(MASS)       # Support Functions and Datasets for Venables and Ripley's MASS
library(factoextra) # Extract and Visualize the Results of Multivariate Data Analyses
library(FactoMineR) # Multivariate Exploratory Data Analysis and Data Mining
library(rstatix)    # Pipe-Friendly Framework for Basic Statistical Tests
library(car)        # Companion to Applied Regression
library(ROCR)       # Visualizing the Performance of Scoring Classifiers

# --- Tidymodels (meta package)
library(rsample)    # General Resampling Infrastructure  
library(broom)      # Convert Statistical Objects into Tidy Tibbles
```

<!-- # Data  -->
<!-- # devtools::install_github("OI-Biostat/oi_biostat_data") -->
<!-- #library(oibiostat) # Data Package for OpenIntro Biostatistics  -->
:::

# DATASETS for today

<br>

::: {style="font-size: 80%;"}
In this tutorial, we will use: 

+ the biopsy data attached to the [`MASS` package](https://cran.r-project.org/web/packages/MASS/MASS.pdf). 
+ a few clean datasets used in the "Core Statistics using R" course by: [Martin van Rongen](https://github.com/mvanrongen/corestats-in-r_tidyverse)

:::


## [Dataset on Breast Cancer Biopsy]{.fit-title}

::: {style="font-size: 95%;"}
**Name**: Biopsy Data on Breast Cancer Patients  
**Documentation**: See reference on the data downloaded and conditioned for R here [https://cran.r-project.org/web/packages/MASS/MASS.pdf](https://cran.r-project.org/web/packages/MASS/MASS.pdf)  
**Sampling details**: This breast cancer database was obtained from the University of Wisconsin Hospitals, Madison from Dr. William H. Wolberg. He assessed biopsies of breast tumours for 699 patients up to 15 July
1992; each of nine attributes has been scored on a scale of 1 to 10, and the outcome is also known. The dataset contains the original Wisconsin breast cancer data with 699 observations on 11 variables.  
::: 

## [Importing Dataset `biopsy`]{.fit-title}

<!-- + **[Option 1]** the data can be directly obtained form the `MASS` R package -->
<!--   + Adapting the function `here` to match your own folder structure -->

<!-- <!-- FATTO IO MA LORO NON VEDONO -->  
<!-- ```{r} -->
<!-- #| eval: false -->
<!-- #| output: false -->
<!-- #| echo: false -->

<!-- # (after loading pckg) -->
<!-- library(MASS) # Support Functions and Datasets for Venables and Ripley's MASS -->
<!-- # I can call  -->
<!-- utils::data(biopsy) -->

<!-- # li salvo nel mio folder per poi darglieli  -->
<!-- readr::write_csv(biopsy, file = here::here("practice", "data_input", "04_datasets", -->
<!--                                       "biopsy.csv")) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| eval: false -->
<!-- #| output: false -->
<!-- #| echo: true -->

<!-- # (Check my working directory location) -->

<!-- # Use `here` in specifying all the subfolders AFTER the working directory  -->
<!-- biopsy2 <- readr::read_csv(file = here::here("practice", "data_input", "04_datasets", -->
<!--                                       "biopsy.csv") ,  -->
<!--                           show_col_types = FALSE, -->
<!--                           col_types = c("c", # ID,  -->
<!--                                          "i", "i", "i", "i", "i", "i", "i", "i", "i",   #V1:V9  -->
<!--                                          "f"  #class  -->
<!-- )) -->
<!-- ``` -->

+ The data can be interactively obtained form the `MASS` R package

```{r}
# (after loading pckg)
# library(MASS)  

# I can call 
utils::data(biopsy)
```

 
## [`biopsy` variables with description]{.fit-title}

::: {style="font-size: 80%;"}
<!-- [[EXCERPT: see complete file in Input Data Folder]]{style="color:#77501a"} -->

```{r}
#| output: true
#| echo: false

biopsy_desc <- tibble::tribble(
  ~Variable, ~ Type, ~Description,
#"X" ,  "integer" ,         "row counter ", 
"ID" ,   "character",               "Sample ID",
"V1",    "integer 1 - 10",        "clump thickness",       
"V2",    "integer 1 - 10",        "uniformity of cell size",   
"V3",    "integer 1 - 10",        "uniformity of cell shape",  
"V4",    "integer 1 - 10",        "marginal adhesion",              
"V5",    "integer 1 - 10",        "single epithelial cell size",   
"V6",    "integer 1 - 10",        "bare nuclei (16 values are missing)",
"V7",    "integer 1 - 10",        "bland chromatin",             
"V8",    "integer 1 - 10",        "normal nucleoli",       
"V9",    "integer 1 - 10",        "mitoses",               
"class", "factor"     ,        "benign or malignant" )                 

kableExtra::kable(biopsy_desc)
```
:::

## [`biopsy` variables exploration]{.fit-title}
::: {style="font-size: 90%;"}
The `biopsy` data contains **699 observations of 9 continuous variables**, `V1`, `V2`, ..., `V9`.  

The dataset also contains a character variable: `ID`, and a factor variable: `class`, with two levels ("benign" and "malignant").

```{r}
# check variable types
str(biopsy)
```
:::

## [`biopsy` missing data]{.fit-title}
::: {style="font-size: 90%;"}
There is one incomplete variable `V6` = "bare nuclei" with 16 missing values. 

  + remember the package `skimr` for exploring a dataframe?
```{r}
# check if vars have missing values
biopsy %>% 
  # select only variables starting with "V"
  skimr::skim(starts_with("V")) %>%
  dplyr::select(skim_variable, 
                n_missing)
```


```{r}
#| eval: false
#| echo: false
#| output: false

# [or] check vars with missing values
purrr::map (biopsy, skimr::n_missing  )
```

:::


<!-- ```{r} -->
<!-- # check for missing data -->
<!-- (missing_data  <-  biopsy %>%  -->
<!--   purrr::map_df(~sum(is.na(.))) %>% -->
<!--   tidyr::gather(., key = "Variable", value = "Missing") -->

<!-- ) -->
<!-- ``` -->



# LOGISTIC REGRESSION: 1 EXAMPLE of SUPERVISED ML ALGORITHM 
<!-- https://openintro-ims.netlify.app/regression-modeling -->
<!-- STATQUEST YT https://www.youtube.com/watch?v=C4N3_XJJ-jU -->
 <!-- STATQUEST GH  https://github.com/StatQuest/logistic_regression_demo/blob/master/logistic_regression_demo.R -->
<!-- https://github.com/sws8/biopsy-analysis/blob/main/biopsy_analysis.pdf -->
<!-- https://www.linkedin.com/pulse/logistic-regression-dataset-biopsy-giancarlo-ronci-twpke/ -->
<!-- EQUITABLE EQUATIONS = https://youtu.be/E7J3M1oYVlc?si=zmBIfoqvErliFqU3 -->


## [Logistic Regr.: review]{.fit-title}
<!-- GLM intro https://medium.com/@sahin.samia/a-comprehensive-introduction-to-generalized-linear-models-fd773d460c1d -->

::: {style="font-size: 90%;"}
+ Logistic regression is used to model a **binary response variable**, e.g. `yes|no`, or `benign|malignant` in the `biopsy` dataset.

+ Logistic regression is a type of `Generalized Linear Model (GLM)`: is a more flexible version of linear regression that can work also for `categorical response` variables (e.g. logistic regression) or `count data` (e.g. poisson regression).

+ `GLMs` (introduced in 1972) provide a unified framework to accommodate response variables that come from a wide range of distributions:

  + the `error distribution` (or `family`) of the response variable can be a `normal distribution` (continuous response), but also a `binomial distribution` (binary response), a `Poisson distribution` (count data), etc. 
  + the `link function` is used to model the relationship between the predictors and the response variable. For example, in logistic regression, the link function is the `logit` function.
  
  
  
  <!-- + GLM can be thought of as a two-stage modeling approach. We first model the response variable using a probability distribution. Second, we model the parameter of the distribution using a collection of predictors and a special form of multiple regression.  -->
  
  <!-- Ultimately, the application of a GLM will feel very similar to multiple regression, even if some of the details are different. -->
:::

## [Logistic Regr.: `logit` function]{.fit-title}
::: {style="font-size: 90%;"}
If we have predictor variables like $x_{1,i}$, $x_{2,i}$, ..., $x_{k,i}$ and a binary response variable $y_i$ (where $y_i = 0$ or $y_i = 1$), we need a **"special" function** (or `link` function) able to transform the expected value of the response variable into the outcome we’re trying to predict. So:

If $p_i$ is the probability that $y_i = 1$...
$$
logit (p_i) = \beta_0 + \beta_1 x_{1,i} + \beta_2 x_{2,i} + \cdots + \beta_k x_{k,i}
$$

...the **`logit` function** is defined as:

$$
logit(p_i) = \ln\left( \frac{p_i}{1-p_i} \right)
$$

R fits the coefficients $\beta_0$, $\beta_1$, ..., $\beta_k$ to the data using the `maximum likelihood estimation` method.

::: aside
+ Predicting probabilities without a `logit` function could give values over 1, which doesn’t make sense.
<!-- + Predicting counts without a `log link` could result in negative numbers, which are impossible. -->
::: 
:::

## [`Biopsy` dataset exploration]{.fit-title}

::: {style="font-size: 75%;"}
+ Biopsied cells of 700 breast cancer tumors, used to determine if the tumors were benign or malignant. 
+ This determination was based on 9 characteristics of the cells, ranked from 1(benign) to 10(malignant):
  + **1) Clump Thickness** – How the cells aggregate. If monolayered they are benign and if clumped on top of each other they are malignant
  + **2) Uniform Size** – All cells of the same type should be the same size.
  + **3) Uniform Shape** If cells vary in cell shape they could be malignant
  + **4) Marginal Adhesion** – Healthy cells have a strong ability to stick together whereas cancerous cells do not
  + **5) Single Epithelial Size** – If epithelial cells are not equal in size, it could be a sign of cancer
  + **6) Bare nuclei** – If the nucleus of the cell is not surrounded by cytoplasm, the cell could be malignant
  + **7) Bland Chromatin** – If the chromatin's texture is coarse the cell could be malignant
  + **8) Normal Nucleoli** – In a healthy cell the nucleoli is small and hard detect via imagery. Enlarged nucleoli could be a sign of cancer
  + **9) Mitosis** – cells that multiply at an uncontrollable rate could be malignant

:::


## [`Biopsy` dataset cleaning]{.fit-title}

::: {style="font-size: 85%;"}
+ `ID` is the patient ID to ensure anonymity (not used in the analysis)
+ `Class` represents the diagnosis, either *benign* or *malignant*, of the patient.
+ Our **goal** is to understand which variables affect the malignancy of a breast cancer tumor. 
  + This will help to **predict a diagnosis** with the least amount of false positives and false negatives.


```{r}
#| output-location: column

# remove rows with missing values
biopsy_clean = na.omit(biopsy)
# rename the columns
colnames(biopsy_clean) <- c("ID","Clump_Thickness", 
                  "Uniform_Size", 
                  "Uniform_Shape",
                  "Marginal_Adhesion", 
                  "Single_Epith_Size", 
                  "Bare_Nuclei",
                  "Bland_Chromatin", 
                  "Normal_Nuclei",
                  "Mitosis", 
                  "Class")
# check the structure of the dataset
paint::paint(biopsy_clean)

# remove the ID column
biopsy_clean$ID = NULL
```
::: 

## [`Biopsy` sample splitting]{.fit-title}

In ML, it is good practice to split the data into `training` and `testing` sets.

+ We will use the training set to fit the model and the testing set to evaluate the model's performance.
```{r}
set.seed(123)

split  <-  sample(nrow(biopsy_clean), 0.8*nrow(biopsy_clean))
biopsy_train  <-  biopsy_clean[split,]
biopsy_test  <-  biopsy_clean[-split,]
```


## [Indipendent variables' visualization]{.fit-title}

::: {style="font-size: 80%;"}
The plot (fig-boxplot) shows the distribution of each variables between the 2 classes of the tumor. 
 
+ All variables behave similarly, with values between 1 and 2 classified as benign and values greater than 2 classified as malignant. 

+ The spread for malignancy is much larger than benign patients so we will keep it in mind when testing our data. 

```{r}
#| label: fig-boxplot
#| output-location: slide
#| fig-cap: |
#|  Boxplot of the independent variables <br> 
#|   - each of the 9 variables is plotted against the class of the tumor <br>
#|   - values are consitently higher & more dispersed for malignant tumors 

ggdf = data.frame("Level" = c(biopsy_train$Clump_Thickness, biopsy_train$Uniform_Size,
                              biopsy_train$Uniform_Shape, biopsy_train$Marginal_Adhesion,
                              biopsy_train$Single_Epith_Size, biopsy_train$Bare_Nuclei,
                              biopsy_train$Bland_Chromatin, biopsy_train$Normal_Nuclei,
                              biopsy_train$Mitosis),
                  "Type" = c("Clump Thickness", "Uniform Size", "Unifrom Shape",
                             "Marginal Adhesion", "Single Epithilial Size", "Bare Nuclei",
                             "Bland Chromatin", "Normal Nuclei", "Mitosis"), 
                  "class" = C(biopsy_train$Class))

# Plot
ggplot(ggdf, aes(x = Level, y = class , colour = class)) + 
  geom_boxplot(fill = NA) +
  scale_color_manual(values = c("#005ca1", "#9b2339")) + 
  geom_jitter(aes(fill = class), alpha = 0.25, shape = 21, width = 0.2) +  
  scale_fill_manual(values = c("#57b7ff", "#e07689")) +  
  facet_wrap(~Type, scales = "free") +  
  theme(plot.title = element_text(size = 13,face="bold", color = "#873c4a"),
        axis.text.x = element_text(size=12,face="italic"), 
        axis.text.y = element_text(size=12,face="italic"),
        legend.position = "none") + 
  labs(title = "Distribution of each explanatory variable by tumor class (benign/malignant) in samples" ) + 
  ylab(label = "") + xlab(label = "")
```
:::


## [Logistic Regr.: model fitting]{.fit-title}

::: {style="font-size: 90%"}
+ We fit a **logistic regression model** to the `biopsy_train` data using:
  + the `glm` function with argument `family = binomial` to specify the logistic regression model;
  + and with `Class ~ .` to specify an initial model that uses all the variables as predictors (**backward elimination** approach).

```{r}
# Building initial model 
model = stats::glm(Class ~ . , family = binomial, data=biopsy_train)
```

+ @tbl-logit_null shows the model `summary`, with the `coefficient estimate` for each  predictor.
  + the `broom::tidy` function converts the model summary into a data frame.

```{r}
#| echo: true
#| output: false

broom::tidy(model) %>% 
  mutate('Sign.lev' = case_when(
    `p.value` < 0.001 ~ "***",
    `p.value` < 0.01 ~ "**",
    `p.value` < 0.05 ~ "*",
    TRUE ~ ""))%>%
  mutate(across(where(is.numeric), ~ round(.x, 4))) %>%
  knitr::kable() 
```

:::


## [Logistic Regr.: summary]{.fit-title}

```{r}
#| echo: false
#| output: true
#| output-location: default
#| label: tbl-logit_null
#| tbl-cap: |
#|  Complete logistic regression model <br>
#|    + coefficients are in the form of `natural logarithm of the odds` of the event happening  <br>
#|    + `positive estimate` indicates an increase in the odds of finding a malignant tumor

broom::tidy(model) %>% 
  mutate('signif. lev.' = case_when(
    `p.value` < 0.001 ~ "***",
    `p.value` < 0.01 ~ "**",
    `p.value` < 0.05 ~ "*",
    TRUE ~ ""))%>%
  mutate(across(where(is.numeric), ~ round(.x, 4))) %>%
  knitr::kable() 
```

## [Logistic Regr.: coefficients' interpretation]{.fit-title} 

::: {style="font-size: 75%"}
As discussed before, in logistic regression, the coefficients are in the form of the `natural logarithm of the odds` of the response event happening (i.e. $Y_i = 1$):

$$logit(p_i) = \ln\left( \frac{p_i}{1-p_i} \right) = -9.5063 + 0.3935 \times Clump\_Thickness + ... + 0.5065 \times Mitosis$$

However, with some algebraic transformation, the `logit` function can be inverted to obtain the `probability of the response event happening` as a function of the predictors:

$$p_i = \frac{1}{1 + e^{-(-9.5063 + 0.3935 \times Clump\_Thickness + ... + 0.5065 \times Mitosis)}}$$

This equation represents the logistic regression model's best-fit line.
:::

<!-- ## [🟡 Logistic Regr.: coefficients' interpretation]{.fit-title}  -->
<!-- <!-- STATS QUEST https://github.com/StatQuest/logistic_regression_demo/blob/master/logistic_regression_demo.R -->  

<!-- ::: {style="font-size: 75%;"} -->

<!-- @tbl-logistic shows the estimated coefficients of the logistic regression model in the form of `natural logarithm of the odds` of an event happening:   -->

<!-- $odds = \frac{p}{1-p}$ ,  $Estimate = \log-odds = \log\left(\frac{p}{1-p}\right)$  -->

<!-- + `Intercept's` (*negative* and *significant*) indicates that when all other variables are 0, the log-odds of a malignant tumor **decreases** by 9.50632.  -->

<!-- + `Bare_Nuclei`, `Clump_Thickness` and `Marginal_Adhesion` have *positive* and *significant*) coefficients.  -->
<!--   + They represent the change in the log-odds of the outcome (a malignant tumor) for a one-unit increase in the predictor, holding other predictors constant.   -->

<!-- ```{r} -->
<!-- #| label: tbl-logistic -->
<!-- #| tbl-cap: Estimated coefficients of the logistic regression -->
<!-- #| output-location: slide -->

<!-- summary(model)$coefficients %>% -->
<!--   as.data.frame() %>% -->
<!--   mutate(Signif. = case_when( -->
<!--     `Pr(>|z|)` < 0.001 ~ "***", -->
<!--     `Pr(>|z|)` < 0.01 ~ "**", -->
<!--     `Pr(>|z|)` < 0.05 ~ "*", -->
<!--     TRUE ~ "")) %>% -->
<!--   mutate(Estimate = round(Estimate, 4)) %>%  -->
<!--   select(1,5) %>%  -->
<!--   kable() -->
<!-- ``` -->
<!-- ::: -->


<!-- ## [🚫 Logistic Regr.: model evaluation]{.fit-title}  -->
<!-- <!-- EQUITABLE EQUATIONS = https://youtu.be/E7J3M1oYVlc?si=zmBIfoqvErliFqU3 --> -->

<!-- Here I am verifying the logit shape . . .  -->

<!-- ```{r} -->
<!-- df_sum <- biopsy_train %>%  -->
<!--   # just one variable  -->
<!--   select(Bare_Nuclei, Class) %>%  -->
<!--   group_by(Bare_Nuclei) %>% -->
<!--   summarise( prop_malig = mean(Class == "malignant"), -->
<!--              count = n()) -->


<!-- ggplot(df_sum, aes (x = Bare_Nuclei,  -->
<!--                       y = prop_malig)) + -->
<!--   geom_point() -->
<!-- ``` -->


## [Logistic Regr.: multicollinearity]{.fit-title}
Let’s check for **collinearity** using the `VIF` function from the ‘`car`’ package. 

+ A Variance Inflation Factor $VIF > 5$ indicates that there could be severe correlation between predictor variables.

+ The VIF values are all less than 5, which indicates that **there is no severe correlation** between predictor variables in the model.
```{r}
car::vif(model)
```

## [Logistic Regr.: improving the model]{.fit-title}
::: {style="font-size: 85%;"}
+ We can use a statistic called the **Akaike Information Criterion (AIC)** to compare models.
  + In AIC, a penalty is given for including additional variables.
  + The model with **the lowest AIC is considered the best model**.
+ Try fitting more parsimonious models by removing variables that are not significant.

```{r}
# For example let's fit a model without the variable `Uniform_Size`
model2 = glm(Class~ .-Uniform_Size, family = binomial, data=biopsy_train)
 
# Compare the AIC values of the 2 models
tibble(Model = c("model", "model2"), 
       AIC = c(AIC(model), AIC(model2) )) 
```

According to the AIC values, the `model2` seems better (AIC is lower).
:::

# 🖍️🖍️

EQUITABLE EQUATIONS =
https://www.youtube.com/watch?v=_yNWzP5HfGw

STATQUEST https://www.youtube.com/watch?v=yIYKR4sgzI8&list=PLblh5JKOoLUKxzEP5HA2d-Li7IJkHfXSe

## [Logistic Regr.: systematic model selection]{.fit-title}

::: {style="font-size: 75%;"}
+ The `MASS` package's function `stepAIC` enables to perform a systematic model selection (by **AIC**):
  + The `direction` argument specifies the direction of the *stepwise* search.
  + The `trace` argument (if set to `TRUE`) prints out all the steps.

+ The `best_model` has removed these variables:
  + `Uniform_Shape`
  + `Single_Epith_Size`
  + `Normal_Nuclei`
  
+ The `best_model` has the **lowest AIC value** (from 100 to 98.5), despite a **higher Residual Deviance** than the full model (from 80 to 80.6), albeit by a very slight amount.

```{r}
#| output-location: default 
# Select the best model based on AIC
best_model <- MASS::stepAIC(model, direction = "both", trace = FALSE)

# Compare the AIC values of full and best model
tibble(Model = c("model", "best_model"), 
       AIC = c(AIC(model), AIC(model2)),
       Deviance = c(deviance(model), deviance(best_model))) %>% kable()
```
:::

```{r}
#| echo: false
#| eval: false

# OR separate extraction
formula(best_model)
coef(best_model)
AIC(best_model)
deviance(best_model)

stepwise_model <- MASS::stepAIC(model, direction = "both", trace = TRUE)
AIC(stepwise_model)
# compare manual AIC and stepAIC
aic_manual <- sapply(list(model, stepwise_model), AIC)
aic_manual
```



## [Logistic Regr.: model evaluation on `test data`]{.fit-title}
::: {style="font-size: 80%;"}
+ We can use the `predict` function to predict the class of the `test data` using the best model.
+ Then we use the `ROCR` package evaluate and visualize the classification 
  + the `performance` function calculates the **True Positive Rate (TPR)** and **False Positive Rate (FPR)** for various thresholds. From it we can get:
    + `tpr` = **True Positive Rate (TPR)** is the proportion of actual positive cases that are correctly predicted as positive.
    + `fpr` = **False Positive Rate (FPR)** is the proportion of actual negative cases that are incorrectly predicted as positive.
    + `thresholds` = the list of thresholds used to calculate the TPR and FPR.

```{r}
# Fitted value for the test data 205 samples based on model
pred = stats::predict(best_model, biopsy_test, type = "response")
# Create a prediction object for the ROCR package
ROCRPRed <- ROCR::prediction(predictions = pred, labels = biopsy_test$Class)
# Create a performance object (True Positive Rate and False Positive Rate) for various thresholds.
ROCRPerf <- ROCR::performance(ROCRPRed, "tpr", "fpr")
# Extract TPR and FPR data
fpr <- ROCRPerf@x.values[[1]] # x
tpr <- ROCRPerf@y.values[[1]] # y
# List of thresholds used to calculate the TPR and FPR in the performance object
thresholds <- ROCRPerf@alpha.values[[1]]
```
:::


## 🙄🤔 [Logistic Regr.: visualization of model performance at varying thresholds]{.fit-title}


```{r}
#| echo: false
#| output: false

# plot the ROC curve
ROCR::plot( ROCRPerf ,  
           colorize=TRUE, 
           print.cutoffs.at=seq(0.1, by=0.2) , 
           xlim=c(0,0.1), 
           ylim=c(0.8,1)
           )

 
```

```{r}
#| output-location: slide
#| fig-subcap: "Threshold color gradient: YELLOW = the model predicts positive only for very confident cases, PURPLE: the model predicts positive for many cases, even with lower confidence."

# Create a data frame for ggplot2
perf_data <- data.frame(FPR = fpr, TPR = tpr, Threshold = thresholds)

# Plot using ggplot2
library(ggplot2)
ggplot(perf_data, aes(x = FPR, y = TPR, color = Threshold)) +
  geom_line(linewidth = 1) +
  scale_color_viridis_c(option = "C") +  # Optional: better color scale
  labs(title = "TPR vs FPR",
       x = "False Positive Rate [0, 0.1]",
       y = "True Positive Rate [0.8, 1]",
       color = "Threshold ") +
  coord_cartesian(xlim = c(0, 0.1), ylim = c(0.8, 1)) +
  theme_minimal()
```

The practical use of this is to identify a threshold where the **True Positive Rate (TPR)** is acceptably high, without a significant increase in **False Positive Rate (FPR)**. 

## [Logistic Regr.: confusion matrix]{.fit-title}
We create a confusion matrix with diﬀerent acceptance rates so we can see how it aﬀects the true and false positivity rates.

> Since our data involves diagnosing malignant tumors, it is important to keep the false negative rate low as this would be telling someone who has a malignant tumor that it is benign. 

+ We found that **a cutoﬀ of 0.4** gives a good balance of low false negatives while still maintaining a high true positive rate.

```{r}
table(ActualValue=biopsy_test$Class, PredictedValue=pred>0.4)
table(ActualValue=biopsy_test$Class, PredictedValue=pred>0.7)
```

## [Logistic Regr.: ROC curve]{.fit-title}
::: {style="font-size: 90%;"}
```{r}
#| output-location: slide
#| fig-subcap: "This shows why lowering the cutoﬀ improves the accuracy of the model as some malignant tumors are being underestimated which would cause false negatives."

predicted.test <- predict(best_model, biopsy_test, type = "response")

predicted.data <- data.frame(prob.of.malig=predicted.test, malig = biopsy_test$Class)

predicted.data <- predicted.data[order(predicted.data$prob.of.malig, decreasing = F),]

predicted.data$rank <- 1:nrow(predicted.data)

plot_ROC <- ggplot(data=predicted.data, aes(x=rank, y=prob.of.malig)) +
  geom_point(aes(color=malig), alpha=1, shape=4, stroke=2) +
  xlab("Index") + 
  ylab("Predicted Probability of Tumor Being Malignant")  

plot_ROC
```
:::

## [Logistic Regr.: conclusions]{.fit-title}

+ `Uniform Size` and `Single Epithithial Size` were not significant in predicting the malignancy of tumor cells so our model does not include these variables. 

+ Our fitted model reduces the null deviance and AIC without impacting the residual deviance by a significant amount and is able to predict the testing dataset with >90% accuracy.

+ For further analysis, we could run the model multiple times because our original and revised model are similar. 

+ New training and testing data would help confirm our results and help identify possible overfitting.


## [...]{.fit-title}

# 🟠 K-MEANS CLUSTERING: EXAMPLE of UNSUPERVISED ML ALGORITHM

## [...]{.fit-title}

# PCA: EXAMPLE of UNSUPERVISED ML ALGORITHM

Reducing high-dimensional data to a lower number of variables
<!-- 1) PCA fatta a mano. -->
<!-- PCA step by step come in Statology ma con il data set della Lecture nmr_bins…csv  -->

<!-- https://www.statology.org/principal-components-analysis-in-r/ -->

<!-- Probabilmente non viene proprio uguale perchè in MA fa normalizzazione e scaling mentre Statology fa solo scaling, ma fa niente, diciamo che ci serve per vedere la differenza -->

## [`biopsy` dataset manipulation]{.fit-title}

We will: 

+ exclude the non-numerical variables (`ID` and `class`) before conducting the PCA.   
+ exclude the individuals with missing values using the `na.omit()` or `filter(complete.cases()` functions.

+ We can do both in 2 equivalent ways:

<br> 

:::: {.columns}

::: {.column width="50%"}
#### with `base` R (more compact)
```{r}
#| eval: false

# new (manipulated) dataset 
data_biopsy <- na.omit(biopsy[,-c(1,11)])
```
:::
  
::: {.column width="50%"}
#### with `dplyr` (more explicit)
```{r}
# new (manipulated) dataset 
data_biopsy <- biopsy %>% 
  # drop incomplete & non-integer columns
  dplyr::select(-ID, -class) %>% 
  # drop incomplete observations (rows)
  dplyr::filter(complete.cases(.))
```
:::
  
::::


## [`biopsy` dataset manipulation]{.fit-title}

We obtained a new dataset with 9 variables and 683 observations (instead of the original 699).  
```{r}
# check reduced dataset 
str(data_biopsy)
```


## Calculate Principal Components

The first step of PCA is to calculate the principal components. To accomplish this, we use the `prcomp()` function from the `stats` package.  

+ With argument `“scale = TRUE”` each variable in the biopsy data is scaled to have a mean of `0` and a standard deviation of `1` before calculating the principal components (just like option `Autoscaling` in MetaboAnalyst)


```{r}
# calculate principal component
biopsy_pca <- prcomp(data_biopsy, 
                     # standardize variables
                     scale = TRUE)
```


## Analyze Principal Components

Let’s check out the elements of our obtained `biopsy_pca` object 

  + (All accessible via the  `$` operator)


```{r}
names(biopsy_pca)
```

**"sdev"** = the standard deviation of the principal components

**"sdev"\^2** = the variance of the principal components (**eigenvalues** of the covariance/correlation matrix)

**"rotation"** = the matrix of variable **loadings** (i.e., a matrix whose columns contain the **eigenvectors**).

**"center"** and **"scale"** = the means and standard deviations of the original variables before the transformation;

**"x"** = the principal component scores (after PCA the observations are expressed in principal component scores)

## Analyze Principal Components (cont.)

::: {style="font-size: 90%;"}
We can see the summary of the analysis using the `summary()` function

1. The first row gives the **Standard deviation** of each component, which can also be retrieved via `biopsy_pca$sdev`. 
2. The second row shows the **Proportion of Variance**, i.e. the percentage of explained variance.

```{r}
summary(biopsy_pca)
```
:::


## [Proportion of Variance for components]{.fit-title}

2. The row with **Proportion of Variance** can be either accessed from summary or calculated as follows:

```{r}
# a) Extracting Proportion of Variance from summary
summary(biopsy_pca)$importance[2,]

# b) (same thing)
round(biopsy_pca$sdev^2 / sum(biopsy_pca$sdev^2), digits = 5)
```

<br>

> The output suggests the **1st principal component** explains around 65% of the total variance, the **2nd principal component** explains about 9% of the variance, and this goes on with diminishing proportion for each component. 


## [Cumulative Proportion of variance for components]{.fit-title}

3. The last row from the `summary(biopsy_pca)`, shows the **Cumulative Proportion** of variance, which calculates the cumulative sum of the Proportion of Variance. 

```{r}
# Extracting Cumulative Proportion from summary
summary(biopsy_pca)$importance[3,]
```

<br>

> Once you computed the PCA in R you must decide the number of components to retain based on the obtained results.


# VISUALIZING PCA OUTPUTS

## Scree plot

There are several ways to decide on the number of components to retain. 

+ One helpful option is visualizing the percentage of explained variance per principal component via a **scree plot**. 
  + Plotting with the `fviz_eig()` function from the `factoextra` package

```{r}
#| output-location: slide
#| fig-cap: "The obtained **scree plot** simply visualizes the output of `summary(biopsy_pca)`."

# Scree plot shows the variance of each principal component 
factoextra::fviz_eig(biopsy_pca, 
                     addlabels = TRUE, 
                     ylim = c(0, 70))
```

<br> 

> Visualization is essential in the interpretation of PCA results. Based on the number of retained principal components, which is usually the first few, the observations expressed in component scores can be plotted in several ways.

## [Principal Component `Scores`]{.fit-title}

After a PCA, the observations are expressed as **principal component scores**.   

1. We can retrieve the principal component scores for each Variable by calling `biopsy_pca$x`, and  store them in a new dataframe `PC_scores`.
2. Next we draw a `scatterplot` of the observations -- expressed in terms of principal components 

```{r}
#| output-location: slide

# Create new object with PC_scores
PC_scores <- as.data.frame(biopsy_pca$x)
head(PC_scores)
```

It is also important to visualize the observations along the new axes (principal components) to interpret the relations in the dataset:

## [Principal Component `Scores` plot (adding label variable)]{.fit-title}

3. When data includes a factor variable, like in our case, it may be interesting to show the grouping on the plot as well.

  + In such cases, the label variable `class` can be added to the PC set as follows.

```{r}
# retrieve class variable
biopsy_no_na <- na.omit(biopsy)
# adding class grouping variable to PC_scores
PC_scores$Label <- biopsy_no_na$class
```

<br>
The visualization of the observation points (point cloud) could be in 2D or 3D.

## [Principal Component `Scores` plot (2D)]{.fit-title}

The Scores Plot can be visualized via the `ggplot2` package. 

+ grouping is indicated by argument the `color = Label`; 
+ `geom_point()` is used for the point cloud.


```{r}
#| output-location: slide
#| fig-cap: "Figure 1 shows the observations projected into the new data space made up of principal components"

ggplot(PC_scores, 
       aes(x = PC1, 
           y = PC2, 
           color = Label)) +
  geom_point() +
  scale_color_manual(values=c("#245048", "#CC0066")) +
  ggtitle("Figure 1: Scores Plot") +
  theme_bw()
```



## [Principal Component `Scores` (2D Ellipse Plot)]{.fit-title}

Confidence ellipses can also be added to a grouped scatter plot visualized after a PCA. We use the `ggplot2` package. 

+ grouping is indicated by argument the `color = Label`; 
+ `geom_point()` is used for the point cloud; 
+ the `stat_ellipse()` function is called to add the ellipses per biopsy group.

```{r}
#| output-location: slide
#| fig-cap: "Figure 2 shows the observations projected into the new data space made up of principal components, with 95% confidence regions displayed." 

ggplot(PC_scores, 
       aes(x = PC1, 
           y = PC2, 
           color = Label)) +
  geom_point() +
  scale_color_manual(values=c("#245048", "#CC0066")) +
  stat_ellipse() + 
  ggtitle("Figure 2: Ellipse Plot") +
  theme_bw()
```



## [Principal Component `Scores` plot (3D)]{.fit-title}

::: {style="font-size: 80%;"}
A 3D scatterplot of observations shows the first **3 principal components’ scores**. 

+ For this one, we need the `scatterplot3d()` function of the `scatterplot3d` package;
+ The color argument assigned to the Label variable;
+ To add a legend, we use the `legend()` function and specify its coordinates via the `xyz.convert()` function.

```{r}
#| output-location: slide
#| fig-cap: "Figure 3 shows the observations projected into the new 3D data space made up of principal components." 

# 3D scatterplot ...
plot_3d <- with(PC_scores, 
                scatterplot3d::scatterplot3d(PC_scores$PC1, 
                                             PC_scores$PC2, 
                                             PC_scores$PC3, 
                                             color = as.numeric(Label), 
                                             pch = 19, 
                                             main ="Figure 3: 3D Scatter Plot", 
                                             xlab="PC1",
                                             ylab="PC2",
                                             zlab="PC3"))

# ... + legend
legend(plot_3d$xyz.convert(0.5, 0.7, 0.5), 
       pch = 19, 
       yjust=-0.6,
       xjust=-0.9,
       legend = levels(PC_scores$Label), 
       col = seq_along(levels(PC_scores$Label)))
```


:::

## [Biplot: principal components v. original variables]{.fit-title}

Next, we create another special type of scatterplot (a **biplot**) to understand the relationship between the principal components and the original variables.  
In the `biplot` each of the observations is projected onto a scatterplot that uses the ***first and second principal components as the axes***.

+ For this plot, we use the `fviz_pca_biplot()` function from the `factoextra` package 
  + We will specify the color for the variables, or rather, for the "loading vectors"
  + The `habillage` argument allows to highlight with color the grouping by `class`

```{r}
#| output-location: slide
#| fig-cap: "The axes show the principal component scores, and the vectors are the loading vectors"

factoextra::fviz_pca_biplot(biopsy_pca, 
                repel = TRUE,
                col.var = "black",
                habillage = biopsy_no_na$class,
                title = "Figure 4: Biplot", geom="point")
```

## Interpreting biplot output
::: {style="font-size: 95%;"}
Biplots have two key elements: **scores** (the 2 axes) and **loadings** (the vectors). 
As in the scores plot, each point represents an observation projected in the space of principal components where:

+ Biopsies of the same class are located closer to each other, which indicates that they have similar **scores**  referred to the 2 main principal components; 
+ The **loading vectors** show strength and direction of association of original variables with new PC variables.

> As expected from PCA, the single `PC1` accounts for variance in almost all original variables, while `V9` has the major projection along `PC2`.

:::

## Interpreting biplot output (cont.)
 
```{r}
scores <- biopsy_pca$x

loadings <- biopsy_pca$rotation
# excerpt of first 2 components
loadings[ ,1:2] 
```

<!-- # PLS-DA: step by step (example) -->
<!-- 1) PCA + PLS_DA + CLuster  -->
<!-- https://rpubs.com/Anita_0736/PD_ANALYSIS  -->

<!-- 2) PLS fatta a mano -->
<!-- PLS step by step come in Statology ma con il data set della Lecture nmr_bins…csv  -->

<!-- https://www.statology.org/partial-least-squares-in-r/ -->

<!-- In MetaboAnalyst usano la PLS-DA che non so cosa ha di diverso ma può essere anche carino vedere la differenza -->



<!-- # ML WITH UNSUPERVISED ALGORITHMS -->

<!-- # Hierarchical Clustering (example) -->
<!-- 3) Hierarchical Clustering fatto a mano come in Statology ma con il data set della Lecture nmr_bins…csv  -->

<!-- https://www.statology.org/hierarchical-clustering-in-r/ -->

<!-- Se non hai tempo o non si riesce l’alternativa è che li faccio giocare anche loro con il MetaboAnalyst anche nelle esercitazioni, sperando che la rete regga e la piattaforma pure.. -->



<!-- # _______   -->

<!-- ## Fonti ...    -->

<!--  + **Cocca**  https://www.statmethods.net/stats/power.html -->

<!--  + **CORESTATS 6 !!!** https://mvanrongen.github.io/corestats-in-r_tidyverse/power-analysis.html  -->

<!--  + **G*Power (free application)** https://www.linkedin.com/learning/the-data-science-of-experimental-design/installing-g-power?resume=false -->
<!--  + **library(pwrss)** https://cran.r-project.org/web/packages/pwrss/vignettes/examples.html#7_Analysis_of_(Co)Variance_(F_Test) -->

<!--  + **dakota** https://med.und.edu/research/daccota/_files/pdfs/berdc_resource_pdfs/sample_size_r_module.pdf -->
<!--  + **!!! Salvatore Mangiafico**  https://rcompanion.org/rcompanion/d_02.html  -->
<!--   + each test ends with power analsyis  -->




## [Recap of the workshop's content]{.fit-title}

::: {style="font-size: 95%;"}

**TOPICS WE COVERED**

1. Motivated the choice of learning/using **R for scientific quantitative analysis**, and lay out some fundamental concepts in biostatistics with concrete R coding examples.

2. Consolidated understanding of **inferential statistic**, through R coding examples conducted on real biostatistics research data.

3. Discussed the **relationship between any two variables**, and introduce a widely used analytical tool: **regression**.
 
4. Presented a popular ML technique for dimensionality reduction (**PCA**), performed both with `MetaboAnalyst` and `R`. 

5. Introduction to **power analysis** to define the correct sample size for hypotheses testing and discussion of how ML approaches deal with available data.


:::


## Final thoughts

::: {style="font-size: 95%;"}
::: {style="color:#77501a"}


+ While the workshop only allowed for a synthetic overview of fundamental ideas, it hopefully provided a solid foundation on the most common statistical analysis you will likely run in your daily work: 
  + Thorough **understanding of the input data** and the data collection process 
  + Univariate and bivariate **exploratory analysis** (accompanied by visual intuition) to form hypothesis 
  + Upon verifying the assumptions, we **fit data** to hypothesized model(s)
  + **Assessment of the model performance** ($R^2$, $Adj. R^2$, $F-Statistic$, etc.)


+ You should now have a solid grasp on the R language to keep using and exploring the huge potential of this programming ecosystem

+ We only scratched the surface in terms of ML classification and prediction models, but we got a hang of the **fundamental steps** and some **useful tools** that might serve us also in more advanced analysis 

:::

:::

